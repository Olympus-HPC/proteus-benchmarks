const char* const kernel_h = "kernel.h\n"
"#include \"spt.h\"\n"
"template<\n"
"    const int ids, const int ide, const int jds, const int jde, const int kds,\n"
"    const int kde, const int ims, const int ime, const int jms, const int jme,\n"
"    const int kms, const int kme, const int ips, const int ipe, const int jps,\n"
"    const int jpe, const int kps, const int kpe>\n"
"__global__ void\n"
"wsm(float *__restrict__ th, const float *__restrict__ pii,\n"
"    float *__restrict__ q, float *__restrict__ qc, float *__restrict__ qi,\n"
"    float *__restrict__ qr, float *__restrict__ qs,\n"
"    const float *__restrict__ den, const float *__restrict__ p,\n"
"    const float *__restrict__ delz, float *__restrict__ rain,\n"
"    float *__restrict__ rainncv, float *__restrict__ sr,\n"
"    float *__restrict__ snow, float *__restrict__ snowncv, const float delt) {\n"
"  float xlf, xmi, acrfac, vt2i, vt2s, supice, diameter;\n"
"  float roqi0, xni0, qimax, value, source, factor, xlwork2;\n"
"  float t_k, q_k, qr_k, qc_k, qs_k, qi_k, qs1_k, qs2_k, cpm_k, xl_k, w1_k, w2_k,\n"
"      w3_k;\n"
"\n"
"#define hsub xls\n"
"#define hvap xlv0\n"
"#define cvap cpv\n"
"  float ttp;\n"
"  float dldt;\n"
"  float xa;\n"
"  float xb;\n"
"  float dldti;\n"
"  float xai;\n"
"  float xbi;\n"
"\n"
"  float qs1[MKX];\n"
"  float qs2[MKX];\n"
"  float rh1[MKX];\n"
"  float rh2[MKX];\n"
"\n"
"  if (ig < ide - ids + 1 && jg < jde - jds + 1) {\n"
"\n"
"    int k;\n"
"\n"
"#include \"constants.h\"\n"
"\n"
"    float t[MKX];\n"
"    float cpm[MKX];\n"
"    float xl[MKX];\n"
"\n"
"    for (k = kps - 1; k <= kpe - 1; k++) {\n"
"      t[k] = th[P3(ti, k, tj)] * pii[P3(ti, k, tj)];\n"
"    }\n"
"\n"
"    for (k = kps - 1; k <= kpe - 1; k++) {\n"
"      if (qc[P3(ti, k, tj)] < 0.f) {\n"
"        qc[P3(ti, k, tj)] = 0.f;\n"
"      }\n"
"      if (qi[P3(ti, k, tj)] < 0.f) {\n"
"        qi[P3(ti, k, tj)] = 0.f;\n"
"      }\n"
"      if (qr[P3(ti, k, tj)] < 0.f) {\n"
"        qr[P3(ti, k, tj)] = 0.f;\n"
"      }\n"
"      if (qs[P3(ti, k, tj)] < 0.f) {\n"
"        qs[P3(ti, k, tj)] = 0.f;\n"
"      }\n"
"    }\n"
"\n"
"    //      latent heat for phase changes and heat capacity. neglect the\n"
"    //      changes during microphysical process calculation\n"
"    //      emanuel(1994)\n"
"\n"
"#define CPMCAL(x) (cpd * (1.f - MAX(x, qmin)) + MAX(x, qmin) * cpv)\n"
"#define XLCAL(x) (xlv0 - xlv1 * ((x)-t0c))\n"
"\n"
"    for (k = kps - 1; k <= kpe - 1; k++) {\n"
"      cpm[k] = CPMCAL(q[P3(ti, k, tj)]);\n"
"      xl[k] = XLCAL(t[k]);\n"
"    }\n"
"\n"
"    //      compute the minor time steps.\n"
"\n"
"    float dtcldcr = 120.f;\n"
"    int loops = delt / dtcldcr + .5f;\n"
"\n"
"    loops = MAX(loops, 1);\n"
"    float dtcld = delt / loops;\n"
"    if (delt <= dtcldcr)\n"
"      dtcld = delt;\n"
"\n"
"    int loop;\n"
"\n"
"    for (loop = 1; loop <= loops; loop++) {\n"
"      //      initialize the large scale variables\n"
"      int mstep = 1;\n"
"\n"
"      ttp = t0c + 0.01f;\n"
"      dldt = cvap - cliq;\n"
"      xa = -dldt / rv;\n"
"      xb = xa + hvap / (rv * ttp);\n"
"      dldti = cvap - cice;\n"
"      xai = -dldti / rv;\n"
"      xbi = xai + hsub / (rv * ttp);\n"
"\n"
"      float tr, ltr, tt, pp, qq;\n"
"\n"
"      for (k = kps - 1; k <= kpe - 1; k++) {\n"
"\n"
"        pp = p[P3(ti, k, tj)];\n"
"        tt = t[k];\n"
"        tr = ttp / tt;\n"
"        ltr = logf(tr);\n"
"\n"
"        qq = psat * expf(ltr * (xa) + xb * (1.f - tr));\n"
"        qq = ep2 * qq / (pp - qq);\n"
"        qs1[k] = MAX(qq, qmin);\n"
"        rh1[k] = MAX(q[P3(ti, k, tj)] / qs1[k], qmin);\n"
"\n"
"        if (tt < ttp) {\n"
"          qq = psat * expf(ltr * (xai) + xbi * (1.f - tr));\n"
"        } else {\n"
"          qq = psat * expf(ltr * (xa) + xb * (1.f - tr));\n"
"        }\n"
"        qq = ep2 * qq / (pp - qq);\n"
"        qs2[k] = MAX(qq, qmin);\n"
"        rh2[k] = MAX(q[P3(ti, k, tj)] / qs2[k], qmin);\n"
"      }\n"
"\n"
"      float prevp_reg;\n"
"      float psdep_reg;\n"
"      float praut_reg;\n"
"      float psaut_reg;\n"
"      float pracw_reg;\n"
"      float psaci_reg;\n"
"      float psacw_reg;\n"
"      float pigen_reg;\n"
"      float pidep_reg;\n"
"      float pcond_reg;\n"
"      float psmlt_reg;\n"
"      float psevp_reg;\n"
"      float xni[MKX];\n"
"\n"
"      for (k = kps - 1; k <= kpe - 1; k++) {\n"
"        xni[k] = 1.e3f;\n"
"      }\n"
"\n"
"#define DIFFUS(x, y) (8.794e-5f * expf(logf(x) * (1.81f)) / (y))\n"
"#define VISCOS(x, y) (1.496e-6f * ((x)*sqrtf(x)) / ((x) + 120.f) / (y))\n"
"#define XKA(x, y) (1.414e3f * VISCOS((x), (y)) * (y))\n"
"#define DIFFAC(a, b, c, d, e)                                                  \\\n"
"  ((d) * (a) * (a) / (XKA((c), (d)) * rv * (c) * (c)) +                        \\\n"
"   1.f / ((e)*DIFFUS((c), (b))))\n"
"#define VENFAC(a, b, c)                                                        \\\n"
"  (expf(logf((VISCOS((b), (c)) / DIFFUS((b), (a)))) * ((.3333333f))) *         \\\n"
"   rsqrtf(VISCOS((b), (c))) * sqrtf(sqrtf(den0 / (c))))\n"
"\n"
"#define LAMDAR(x, y) sqrtf(sqrtf(pidn0r / ((x) * (y))))\n"
"#define LAMDAS(x, y, z) sqrtf(sqrtf(pidn0s *(z) / ((x) * (y))))\n"
"\n"
"      // calculate mstep for this column\n"
"\n"
"      float rsloper[MKX];\n"
"      float rslopebr[MKX];\n"
"      float rslope2r[MKX];\n"
"      float rslope3r[MKX];\n"
"      float rslopes[MKX];\n"
"      float rslopebs[MKX];\n"
"      float rslope2s[MKX];\n"
"      float rslope3s[MKX];\n"
"      float denfac[MKX];\n"
"      float n0sfac[MKX];\n"
"\n"
"      float w1[MKX];\n"
"      float w2[MKX];\n"
"      float w3[MKX];\n"
"\n"
"      float w;\n"
"      float rmstep;\n"
"      int numdt;\n"
"      for (k = kps - 1; k <= kpe - 1; k++) {\n"
"        float supcol = t0c - t[k];\n"
"        n0sfac[k] = MAX(MIN(expf(alpha * supcol), n0smax / n0s), 1.f);\n"
"        if (qr[P3(ti, k, tj)] <= qcrmin) {\n"
"          rsloper[k] = rslopermax;\n"
"          rslopebr[k] = rsloperbmax;\n"
"          rslope2r[k] = rsloper2max;\n"
"          rslope3r[k] = rsloper3max;\n"
"        } else {\n"
"          rsloper[k] = 1.f / LAMDAR(qr[P3(ti, k, tj)], den[P3(ti, k, tj)]);\n"
"          rslopebr[k] = expf(logf(rsloper[k]) * bvtr);\n"
"          rslope2r[k] = rsloper[k] * rsloper[k];\n"
"          rslope3r[k] = rslope2r[k] * rsloper[k];\n"
"        }\n"
"        if (qs[P3(ti, k, tj)] <= qcrmin) {\n"
"          rslopes[k] = rslopesmax;\n"
"          rslopebs[k] = rslopesbmax;\n"
"          rslope2s[k] = rslopes2max;\n"
"          rslope3s[k] = rslopes3max;\n"
"        } else {\n"
"          rslopes[k] =\n"
"              1.f / LAMDAS(qs[P3(ti, k, tj)], den[P3(ti, k, tj)], n0sfac[k]);\n"
"          rslopebs[k] = expf(logf(rslopes[k]) * bvts);\n"
"          rslope2s[k] = rslopes[k] * rslopes[k];\n"
"          rslope3s[k] = rslope2s[k] * rslopes[k];\n"
"        }\n"
"        denfac[k] = sqrtf(den0 / den[P3(ti, k, tj)]);\n"
"        w1[k] = pvtr * rslopebr[k] * denfac[k] / delz[P3(ti, k, tj)];\n"
"        w2[k] = pvts * rslopebs[k] * denfac[k] / delz[P3(ti, k, tj)];\n"
"\n"
"        w = MAX(w1[k], w2[k]);\n"
"        numdt = MAX((int)trunc(w * dtcld + .5f + .5f), 1);\n"
"        if (numdt >= mstep)\n"
"          mstep = numdt;\n"
"        //-------------------------------------------------------------\n"
"        // Ni: ice crystal number concentration   [HDC 5c]\n"
"        //-------------------------------------------------------------\n"
"        float temp = (den[P3(ti, k, tj)] * MAX(qi[P3(ti, k, tj)], qmin));\n"
"        temp = sqrtf(sqrtf(temp * temp * temp));\n"
"        xni[k] = MIN(MAX(5.38e7f * temp, 1.e3f), 1.e6f);\n"
"      }\n"
"      rmstep = 1.f / mstep;\n"
"\n"
"      int n;\n"
"      float dtcldden, coeres, rdelz;\n"
"\n"
"      float den_k, falk1_k, falk1_kp1, fall1_k, delz_k, delz_kp1;\n"
"      float falk2_k, falk2_kp1, fall2_k;\n"
"\n"
"      for (n = 1; n <= mstep; n++) {\n"
"        k = kpe - 1;\n"
"        den_k = den[P3(ti, k, tj)];\n"
"        falk1_kp1 = den_k * qr[P3(ti, k, tj)] * w1[k] * rmstep;\n"
"        falk2_kp1 = den_k * qs[P3(ti, k, tj)] * w2[k] * rmstep;\n"
"        dtcldden = dtcld / den_k;\n"
"        qr[P3(ti, k, tj)] = MAX(qr[P3(ti, k, tj)] - falk1_kp1 * dtcldden, 0.f);\n"
"        qs[P3(ti, k, tj)] = MAX(qs[P3(ti, k, tj)] - falk2_kp1 * dtcldden, 0.f);\n"
"        delz_kp1 = delz[P3(ti, k, tj)];\n"
"        for (k = kpe - 2; k >= kps - 1; k--) {\n"
"          den_k = den[P3(ti, k, tj)];\n"
"          falk1_k = den_k * qr[P3(ti, k, tj)] * w1[k] * rmstep;\n"
"          fall1_k = falk1_k;\n"
"          falk2_k = den_k * qs[P3(ti, k, tj)] * w2[k] * rmstep;\n"
"          fall2_k = falk2_k;\n"
"          dtcldden = dtcld / den_k;\n"
"          delz_k = delz[P3(ti, k, tj)];\n"
"          rdelz = 1.f / delz_k;\n"
"          qr[P3(ti, k, tj)] =\n"
"              MAX(qr[P3(ti, k, tj)] -\n"
"                      (falk1_k - falk1_kp1 * delz_kp1 * rdelz) * dtcldden,\n"
"                  0.f);\n"
"          qs[P3(ti, k, tj)] =\n"
"              MAX(qs[P3(ti, k, tj)] -\n"
"                      (falk2_k - falk2_kp1 * delz_kp1 * rdelz) * dtcldden,\n"
"                  0.f);\n"
"          delz_kp1 = delz_k;\n"
"          falk1_kp1 = falk1_k;\n"
"          falk2_kp1 = falk2_k;\n"
"        }\n"
"\n"
"        for (k = kpe - 1; k >= kps - 1; k--) {\n"
"          if (t[k] > t0c && qs[P3(ti, k, tj)] > 0.f) {\n"
"            xlf = xlf0;\n"
"            w3[k] = VENFAC(p[P3(ti, k, tj)], t[k], den[P3(ti, k, tj)]);\n"
"            coeres = rslope2s[k] * sqrtf(rslopes[k] * rslopebs[2]);\n"
"            psmlt_reg = XKA(t[k], den[P3(ti, k, tj)]) / xlf * (t0c - t[k]) *\n"
"                        pi / 2.f * n0sfac[k] *\n"
"                        (precs1 * rslope2s[k] + precs2 * w3[k] * coeres);\n"
"            psmlt_reg = MIN(\n"
"                MAX(psmlt_reg * dtcld * rmstep, -qs[P3(ti, k, tj)] * rmstep),\n"
"                0.f);\n"
"            qs[P3(ti, k, tj)] += psmlt_reg;\n"
"            qr[P3(ti, k, tj)] -= psmlt_reg;\n"
"            t[k] += xlf / CPMCAL(q[P3(ti, k, tj)]) * psmlt_reg;\n"
"          }\n"
"        }\n"
"      }\n"
"\n"
"      //---------------------------------------------------------------\n"
"      // Vice [ms-1] : fallout of ice crystal [HDC 5a]\n"
"      //---------------------------------------------------------------\n"
"      mstep = 1;\n"
"      numdt = 1;\n"
"      for (k = kpe - 1; k >= kps - 1; k--) {\n"
"        if (qi[P3(ti, k, tj)] <= 0.f) {\n"
"          w2[k] = 0.f;\n"
"        } else {\n"
"          xmi = den[P3(ti, k, tj)] * qi[P3(ti, k, tj)] / xni[k];\n"
"          diameter = MAX(MIN(dicon * sqrtf(xmi), dimax), 1.e-25f);\n"
"          w1[k] = 1.49e4f * expf(logf(diameter) * (1.31f));\n"
"          w2[k] = w1[k] / delz[P3(ti, k, tj)];\n"
"        }\n"
"        numdt = MAX((int)trunc(w2[k] * dtcld + .5f + .5f), 1);\n"
"        if (numdt > mstep)\n"
"          mstep = numdt;\n"
"      }\n"
"      rmstep = 1.f / mstep;\n"
"\n"
"      float falkc_k, falkc_kp1, fallc_k, fallc_kp1;\n"
"      for (n = 1; n <= mstep; n++) {\n"
"        k = kpe - 1;\n"
"        den_k = den[P3(ti, k, tj)];\n"
"        falkc_kp1 = den_k * qi[P3(ti, k, tj)] * w2[k] * rmstep;\n"
"        fallc_kp1 = fallc_kp1 + falkc_kp1;\n"
"        qi[P3(ti, k, tj)] =\n"
"            MAX(qi[P3(ti, k, tj)] - falkc_kp1 * dtcld / den_k, 0.f);\n"
"        delz_kp1 = delz[P3(ti, k, tj)];\n"
"        for (k = kpe - 2; k >= kps - 1; k--) {\n"
"          den_k = den[P3(ti, k, tj)];\n"
"          falkc_k = den_k * qi[P3(ti, k, tj)] * w2[k] * rmstep;\n"
"          fallc_k = fallc_k + falkc_k;\n"
"          delz_k = delz[P3(ti, k, tj)];\n"
"          qi[P3(ti, k, tj)] =\n"
"              MAX(qi[P3(ti, k, tj)] -\n"
"                      (falkc_k - falkc_kp1 * delz_kp1 / delz_k) * dtcld / den_k,\n"
"                  0.f);\n"
"          delz_kp1 = delz_k;\n"
"          falkc_kp1 = falkc_k;\n"
"          fallc_kp1 = fallc_k;\n"
"        }\n"
"      }\n"
"      float fallsum = fall1_k + fall2_k + fallc_k;\n"
"      float fallsum_qsi = fall2_k + fallc_k;\n"
"\n"
"      rainncv[P2(ti, tj)] = 0.f;\n"
"      if (fallsum > 0.f) {\n"
"        rainncv[P2(ti, tj)] =\n"
"            fallsum * delz[P3(ti, 1, tj)] / denr * dtcld * 1000.f;\n"
"        rain[P2(ti, tj)] =\n"
"            fallsum * delz[P3(ti, 1, tj)] / denr * dtcld * 1000.f +\n"
"            rain[P2(ti, tj)];\n"
"      }\n"
"      snowncv[P2(ti, tj)] = 0.f;\n"
"      if (fallsum_qsi > 0.f) {\n"
"        snowncv[P2(ti, tj)] =\n"
"            fallsum_qsi * delz[P3(ti, 0, tj)] / denr * dtcld * 1000.f;\n"
"        snow[P2(ti, tj)] =\n"
"            fallsum_qsi * delz[P3(ti, 0, tj)] / denr * dtcld * 1000.f +\n"
"            snow[P2(ti, tj)];\n"
"      }\n"
"      sr[P2(ti, tj)] = 0.f;\n"
"      if (fallsum > 0.f)\n"
"        sr[P2(ti, tj)] = fallsum_qsi * delz[P3(ti, 0, tj)] / denr * dtcld *\n"
"                         1000.f / (rainncv[P2(ti, tj)] + 1.e-12f);\n"
"\n"
"      //---------------------------------------------------------------\n"
"      // pimlt: instantaneous melting of cloud ice [HL A47] [RH83 A28]\n"
"      //       (T>T0: I->C)\n"
"      //---------------------------------------------------------------\n"
"\n"
"      for (k = kps - 1; k <= kpe - 1; k++) {\n"
"\n"
"        //  note -- many of these are turned into scalars of form name_reg by\n"
"        //  _def_ above so that they will be stored in registers\n"
"        prevp_reg = 0.f;\n"
"        psdep_reg = 0.f;\n"
"        praut_reg = 0.f;\n"
"        psaut_reg = 0.f;\n"
"        pracw_reg = 0.f;\n"
"        psaci_reg = 0.f;\n"
"        psacw_reg = 0.f;\n"
"        pigen_reg = 0.f;\n"
"        pidep_reg = 0.f;\n"
"        pcond_reg = 0.f;\n"
"        psevp_reg = 0.f;\n"
"\n"
"        q_k = q[P3(ti, k, tj)];\n"
"        t_k = t[k];\n"
"        qr_k = qr[P3(ti, k, tj)];\n"
"        qc_k = qc[P3(ti, k, tj)];\n"
"        qs_k = qs[P3(ti, k, tj)];\n"
"        qi_k = qi[P3(ti, k, tj)];\n"
"        qs1_k = qs1[k];\n"
"        qs2_k = qs2[k];\n"
"        cpm_k = cpm[k];\n"
"        xl_k = xl[k];\n"
"\n"
"        float supcol = t0c - t_k;\n"
"        xlf = xls - xl_k;\n"
"        if (supcol < 0.f)\n"
"          xlf = xlf0;\n"
"        if (supcol < 0.f && qi_k > 0.f) {\n"
"          qc_k = qc_k + qi_k;\n"
"          t_k = t_k - xlf / cpm_k * qi_k;\n"
"          qi_k = 0.f;\n"
"        }\n"
"        //---------------------------------------------------------------\n"
"        // pihmf: homogeneous freezing of cloud water below -40c [HL A45]\n"
"        //        (T<-40C: C->I)\n"
"        //---------------------------------------------------------------\n"
"        if (supcol > 40.f && qc_k > 0.f) {\n"
"          qi_k = qi_k + qc_k;\n"
"          t_k = t_k + xlf / cpm_k * qc_k;\n"
"          qc_k = 0.f;\n"
"        }\n"
"        //---------------------------------------------------------------\n"
"        // pihtf: heterogeneous freezing of cloud water [HL A44]\n"
"        //        (T0>T>-40C: C->I)\n"
"        //---------------------------------------------------------------\n"
"        if (supcol > 0.f && qc_k > 0.f) {\n"
"          float pfrzdtc =\n"
"              MIN(pfrz1 * (expf(pfrz2 * supcol) - 1.f) * den[P3(ti, k, tj)] /\n"
"                      denr / xncr * qc_k * qc_k * dtcld,\n"
"                  qc_k);\n"
"          qi_k = qi_k + pfrzdtc;\n"
"          t_k = t_k + xlf / cpm_k * pfrzdtc;\n"
"          qc_k = qc_k - pfrzdtc;\n"
"        }\n"
"        //---------------------------------------------------------------\n"
"        // psfrz: freezing of rain water [HL A20] [LFO 45]\n"
"        //        (T<T0, R->S)\n"
"        //---------------------------------------------------------------\n"
"        if (supcol > 0.f && qr_k > 0.f) {\n"
"          float temp = rsloper[k];\n"
"          temp = temp * temp * temp * temp * temp * temp * temp;\n"
"          float pfrzdtr =\n"
"              MIN(20.f * (pi * pi) * pfrz1 * n0r * denr / den[P3(ti, k, tj)] *\n"
"                      (expf(pfrz2 * supcol) - 1.f) * temp * dtcld,\n"
"                  qr_k);\n"
"          qs_k = qs_k + pfrzdtr;\n"
"          t_k = t_k + xlf / cpm_k * pfrzdtr;\n"
"          qr_k = qr_k - pfrzdtr;\n"
"        }\n"
"\n"
"        //----------------------------------------------------------------\n"
"        //     rsloper: reverse of the slope parameter of the rain(m)\n"
"        //     xka:    thermal conductivity of air(jm-1s-1k-1)\n"
"        //     work1:  the thermodynamic term in the denominator associated with\n"
"        //             heat conduction and vapor diffusion\n"
"        //             (ry88, y93, h85)\n"
"        //     work2: parameter associated with the ventilation effects(y93)\n"
"\n"
"        n0sfac[k] = MAX(MIN(expf(alpha * supcol), n0smax / n0s), 1.f);\n"
"        if (qr_k <= qcrmin) {\n"
"          rsloper[k] = rslopermax;\n"
"          rslopebr[k] = rsloperbmax;\n"
"          rslope2r[k] = rsloper2max;\n"
"          rslope3r[k] = rsloper3max;\n"
"        } else {\n"
"          rsloper[k] =\n"
"              1.f / (sqrtf(sqrtf(pidn0r / ((qr_k) * (den[P3(ti, k, tj)])))));\n"
"          rslopebr[k] = expf(logf(rsloper[k]) * bvtr);\n"
"          rslope2r[k] = rsloper[k] * rsloper[k];\n"
"          rslope3r[k] = rslope2r[k] * rsloper[k];\n"
"        }\n"
"        if (qs_k <= qcrmin) {\n"
"          rslopes[k] = rslopesmax;\n"
"          rslopebs[k] = rslopesbmax;\n"
"          rslope2s[k] = rslopes2max;\n"
"          rslope3s[k] = rslopes3max;\n"
"        } else {\n"
"          rslopes[k] = 1.f / (sqrtf(sqrtf(pidn0s * (n0sfac[k]) /\n"
"                                          ((qs_k) * (den[P3(ti, k, tj)])))));\n"
"          rslopebs[k] = expf(logf(rslopes[k]) * bvts);\n"
"          rslope2s[k] = rslopes[k] * rslopes[k];\n"
"          rslope3s[k] = rslope2s[k] * rslopes[k];\n"
"        }\n"
"\n"
"        w1_k = DIFFAC(xl_k, p[P3(ti, k, tj)], t_k, den[P3(ti, k, tj)], qs1_k);\n"
"        w2_k = DIFFAC(xls, p[P3(ti, k, tj)], t_k, den[P3(ti, k, tj)], qs2_k);\n"
"        w3_k = VENFAC(p[P3(ti, k, tj)], t_k, den[P3(ti, k, tj)]);\n"
"\n"
"        //\n"
"        //===============================================================\n"
"        //\n"
"        // warm rain processes\n"
"        //\n"
"        // - follows the processes in RH83 and LFO except for autoconcersion\n"
"        //\n"
"        //===============================================================\n"
"        //\n"
"        float supsat = MAX(q_k, qmin) - qs1_k;\n"
"        float satdt = supsat / dtcld;\n"
"        //---------------------------------------------------------------\n"
"        // praut: auto conversion rate from cloud to rain [HDC 16]\n"
"        //        (C->R)\n"
"        //---------------------------------------------------------------\n"
"        if (qc_k > qc0) {\n"
"          praut_reg = qck1 * expf(logf(qc_k) * ((7.f / 3.f)));\n"
"          praut_reg = MIN(praut_reg, qc_k / dtcld);\n"
"        }\n"
"        //---------------------------------------------------------------\n"
"        // pracw: accretion of cloud water by rain [HL A40] [LFO 51]\n"
"        //        (C->R)\n"
"        //---------------------------------------------------------------\n"
"        if (qr_k > qcrmin && qc_k > qmin) {\n"
"          pracw_reg = MIN(pacrr * rslope3r[k] * rslopebr[k] * qc_k * denfac[k],\n"
"                          qc_k / dtcld);\n"
"        }\n"
"        //---------------------------------------------------------------\n"
"        // prevp: evaporation/condensation rate of rain [HDC 14]\n"
"        //        (V->R or R->V)\n"
"        //---------------------------------------------------------------\n"
"        if (qr_k > 0.f) {\n"
"          coeres = rslope2r[k] * sqrtf(rsloper[k] * rslopebr[k]);\n"
"          prevp_reg = (rh1[k] - 1.f) *\n"
"                      (precr1 * rslope2r[k] + precr2 * w3_k * coeres) / w1_k;\n"
"          if (prevp_reg < 0.f) {\n"
"            prevp_reg = MAX(prevp_reg, -qr_k / dtcld);\n"
"            prevp_reg = MAX(prevp_reg, satdt / 2.f);\n"
"          } else {\n"
"            prevp_reg = MIN(prevp_reg, satdt / 2.f);\n"
"          }\n"
"        }\n"
"\n"
"        //\n"
"        //===============================================================\n"
"        //\n"
"        // cold rain processes\n"
"        //\n"
"        // - follows the revised ice microphysics processes in HDC\n"
"        // - the processes same as in RH83 and RH84  and LFO behave\n"
"        //   following ice crystal hapits defined in HDC, inclduing\n"
"        //   intercept parameter for snow (n0s), ice crystal number\n"
"        //   concentration (ni), ice nuclei number concentration\n"
"        //   (n0i), ice diameter (d)\n"
"        //\n"
"        //===============================================================\n"
"        //\n"
"        float rdtcld = 1.f / dtcld;\n"
"        supsat = MAX(q_k, qmin) - qs2_k;\n"
"        satdt = supsat / dtcld;\n"
"        int ifsat = 0;\n"
"        //-------------------------------------------------------------\n"
"        // Ni: ice crystal number concentraiton   [HDC 5c]\n"
"        //-------------------------------------------------------------\n"
"        float temp = (den[P3(ti, k, tj)] * MAX(qi_k, qmin));\n"
"        temp = sqrtf(sqrtf(temp * temp * temp));\n"
"        xni[k] = MIN(MAX(5.38e7f * temp, 1.e3f), 1.e6f);\n"
"        float eacrs = expf(0.07f * (-supcol));\n"
"        //-------------------------------------------------------------\n"
"        // psacw: Accretion of cloud water by snow  [HL A7] [LFO 24]\n"
"        //        (T<T0: C->S, and T>=T0: C->R)\n"
"        //-------------------------------------------------------------\n"
"        if (qs_k > qcrmin && qc_k > qmin) {\n"
"          psacw_reg = MIN(pacrc * n0sfac[k] * rslope3s[k] * rslopebs[k] * qc_k *\n"
"                              denfac[k],\n"
"                          qc_k * rdtcld);\n"
"        }\n"
"        //\n"
"        if (supcol > 0) {\n"
"          if (qs_k > qcrmin && qi_k > qmin) {\n"
"            xmi = den[P3(ti, k, tj)] * qi_k / xni[k];\n"
"            diameter = MIN(dicon * sqrtf(xmi), dimax);\n"
"            vt2i = 1.49e4f * powf(diameter, 1.31f);\n"
"            vt2s = pvts * rslopebs[k] * denfac[k];\n"
"            //-------------------------------------------------------------\n"
"            // psaci: Accretion of cloud ice by rain [HDC 10]\n"
"            //        (T<T0: I->S)\n"
"            //-------------------------------------------------------------\n"
"            acrfac = 2.f * rslope3s[k] + 2.f * diameter * rslope2s[k] +\n"
"                     diameter * diameter * rslopes[k];\n"
"            psaci_reg = pi * qi_k * eacrs * n0s * n0sfac[k] * abs(vt2s - vt2i) *\n"
"                        acrfac * .25f;\n"
"          }\n"
"          //-------------------------------------------------------------\n"
"          // pidep: Deposition/Sublimation rate of ice [HDC 9]\n"
"          //       (T<T0: V->I or I->V)\n"
"          //-------------------------------------------------------------\n"
"          if (qi_k > 0 && ifsat != 1) {\n"
"            xmi = den[P3(ti, k, tj)] * qi_k / xni[k];\n"
"            diameter = dicon * sqrtf(xmi);\n"
"            pidep_reg = 4.f * diameter * xni[k] * (rh2[k] - 1.f) / w2_k;\n"
"            supice = satdt - prevp_reg;\n"
"            if (pidep_reg < 0.f) {\n"
"              pidep_reg = MAX(MAX(pidep_reg, satdt * .5f), supice);\n"
"              pidep_reg = MAX(pidep_reg, -qi_k * rdtcld);\n"
"            } else {\n"
"              pidep_reg = MIN(MIN(pidep_reg, satdt * .5f), supice);\n"
"            }\n"
"            if (abs(prevp_reg + pidep_reg) >= abs(satdt))\n"
"              ifsat = 1;\n"
"          }\n"
"          //-------------------------------------------------------------\n"
"          // psdep: deposition/sublimation rate of snow [HDC 14]\n"
"          //        (V->S or S->V)\n"
"          //-------------------------------------------------------------\n"
"          if (qs_k > 0.f && ifsat != 1) {\n"
"            coeres = rslope2s[k] * sqrtf(rslopes[k] * rslopebs[k]);\n"
"            psdep_reg = (rh2[k] - 1.f) * n0sfac[k] *\n"
"                        (precs1 * rslope2s[k] + precs2 * w3_k * coeres) / w2_k;\n"
"            supice = satdt - prevp_reg - pidep_reg;\n"
"            if (psdep_reg < 0.f) {\n"
"              psdep_reg = MAX(psdep_reg, -qs_k * rdtcld);\n"
"              psdep_reg = MAX(MAX(psdep_reg, satdt * .5f), supice);\n"
"            } else {\n"
"              psdep_reg = MIN(MIN(psdep_reg, satdt * .5f), supice);\n"
"            }\n"
"            if (abs(prevp_reg + pidep_reg + psdep_reg) >= abs(satdt))\n"
"              ifsat = 1;\n"
"          }\n"
"          //-------------------------------------------------------------\n"
"          // pigen: generation(nucleation) of ice from vapor [HL A50] [HDC 7-8]\n"
"          //       (T<T0: V->I)\n"
"          //-------------------------------------------------------------\n"
"          if (supsat > 0 && ifsat != 1) {\n"
"            supice = satdt - prevp_reg - pidep_reg - psdep_reg;\n"
"            xni0 = 1.e3f * expf(0.1f * supcol);\n"
"            roqi0 = 4.92e-11f * expf(logf(xni0) * (1.33f));\n"
"            pigen_reg = MAX(0.f, (roqi0 / den[P3(ti, k, tj)] - MAX(qi_k, 0.f)) *\n"
"                                     rdtcld);\n"
"            pigen_reg = MIN(MIN(pigen_reg, satdt), supice);\n"
"          }\n"
"          //\n"
"          //-------------------------------------------------------------\n"
"          // psaut: conversion(aggregation) of ice to snow [HDC 12]\n"
"          //       (T<T0: I->S)\n"
"          //-------------------------------------------------------------\n"
"          if (qi_k > 0.f) {\n"
"            qimax = roqimax / den[P3(ti, k, tj)];\n"
"            psaut_reg = MAX(0.f, (qi_k - qimax) * rdtcld);\n"
"          }\n"
"        }\n"
"        //-------------------------------------------------------------\n"
"        // psevp: Evaporation of melting snow [HL A35] [RH83 A27]\n"
"        //       (T>T0: S->V)\n"
"        //-------------------------------------------------------------\n"
"        if (supcol < 0.f) {\n"
"          if (qs_k > 0.f && rh1[k] < 1.f) {\n"
"            psevp_reg = psdep_reg * w2_k / w1_k;\n"
"          } // asked Jimy about this, 11.6.07, JM\n"
"          psevp_reg = MIN(MAX(psevp_reg, -qs_k * rdtcld), 0.f);\n"
"        }\n"
"\n"
"        //     check mass conservation of generation terms and feedback to the\n"
"        //     large scale\n"
"        if (t_k <= t0c) {\n"
"          //\n"
"          //     cloud water\n"
"          //\n"
"          value = MAX(qmin, qc_k);\n"
"          source = (praut_reg + pracw_reg + psacw_reg) * dtcld;\n"
"          if (source > value) {\n"
"            factor = value / source;\n"
"            praut_reg = praut_reg * factor;\n"
"            pracw_reg = pracw_reg * factor;\n"
"            psacw_reg = psacw_reg * factor;\n"
"          }\n"
"          //\n"
"          //     cloud ice\n"
"          //\n"
"          value = MAX(qmin, qi_k);\n"
"          source = (psaut_reg + psaci_reg - pigen_reg - pidep_reg) * dtcld;\n"
"          if (source > value) {\n"
"            factor = value / source;\n"
"            psaut_reg = psaut_reg * factor;\n"
"            psaci_reg = psaci_reg * factor;\n"
"            pigen_reg = pigen_reg * factor;\n"
"            pidep_reg = pidep_reg * factor;\n"
"          }\n"
"\n"
"          //\n"
"          //     rain (added for WRFV3.0.1)\n"
"          //\n"
"          value = MAX(qmin, qr_k);\n"
"          source = (-praut_reg + pracw_reg - prevp_reg) * dtcld;\n"
"          if (source > value) {\n"
"            factor = value / source;\n"
"            praut_reg = praut_reg * factor;\n"
"            pracw_reg = pracw_reg * factor;\n"
"            prevp_reg = prevp_reg * factor;\n"
"          }\n"
"          //\n"
"          //     snow (added for WRFV3.0.1)\n"
"          //\n"
"          value = MAX(qmin, qs_k);\n"
"          source = (-psdep_reg + psaut_reg - psaci_reg - psacw_reg) * dtcld;\n"
"          if (source > value) {\n"
"            factor = value / source;\n"
"            psdep_reg = psdep_reg * factor;\n"
"            psaut_reg = psaut_reg * factor;\n"
"            psaci_reg = psaci_reg * factor;\n"
"            psacw_reg = psacw_reg * factor;\n"
"          }\n"
"          //     (end added for WRFV3.0.1)\n"
"\n"
"          //\n"
"          w3_k = -(prevp_reg + psdep_reg + pigen_reg + pidep_reg);\n"
"          //     update\n"
"          q_k = q_k + w3_k * dtcld;\n"
"          qc_k = MAX(qc_k - (praut_reg + pracw_reg + psacw_reg) * dtcld, 0.f);\n"
"          qr_k = MAX(qr_k + (praut_reg + pracw_reg + prevp_reg) * dtcld, 0.f);\n"
"          qi_k = MAX(qi_k - (psaut_reg + psaci_reg - pigen_reg - pidep_reg) *\n"
"                                dtcld,\n"
"                     0.f);\n"
"          qs_k = MAX(qs_k + (psdep_reg + psaut_reg + psaci_reg + psacw_reg) *\n"
"                                dtcld,\n"
"                     0.f);\n"
"          xlf = xls - xl_k;\n"
"          xlwork2 = -xls * (psdep_reg + pidep_reg + pigen_reg) -\n"
"                    xl_k * prevp_reg - xlf * psacw_reg;\n"
"          t_k = t_k - xlwork2 / cpm_k * dtcld;\n"
"        } else {\n"
"          //\n"
"          //     cloud water\n"
"          //\n"
"          value = MAX(qmin, qc_k);\n"
"          source = (praut_reg + pracw_reg + psacw_reg) * dtcld;\n"
"          if (source > value) {\n"
"            factor = value / source;\n"
"            praut_reg = praut_reg * factor;\n"
"            pracw_reg = pracw_reg * factor;\n"
"            psacw_reg = psacw_reg * factor;\n"
"          }\n"
"          //\n"
"          //     rain (added for WRFV3.0.1)\n"
"          //\n"
"          value = MAX(qmin, qr_k);\n"
"          source = (-praut_reg - pracw_reg - prevp_reg - psacw_reg) * dtcld;\n"
"          if (source > value) {\n"
"            factor = value / source;\n"
"            praut_reg = praut_reg * factor;\n"
"            pracw_reg = pracw_reg * factor;\n"
"            prevp_reg = prevp_reg * factor;\n"
"            psacw_reg = psacw_reg * factor;\n"
"          }\n"
"          //     (end added for WRFV3.0.1)\n"
"          //\n"
"          //     snow\n"
"          //\n"
"          value = MAX(qcrmin, qs_k);\n"
"          source = (-psevp_reg) * dtcld;\n"
"          if (source > value) {\n"
"            factor = value / source;\n"
"            psevp_reg = psevp_reg * factor;\n"
"          }\n"
"          w3_k = -(prevp_reg + psevp_reg);\n"
"          //     update\n"
"          q_k = q_k + w3_k * dtcld;\n"
"          qc_k = MAX(qc_k - (praut_reg + pracw_reg + psacw_reg) * dtcld, 0.f);\n"
"          qr_k = MAX(qr_k + (praut_reg + pracw_reg + prevp_reg + psacw_reg) *\n"
"                                dtcld,\n"
"                     0.f);\n"
"          qs_k = MAX(qs_k + psevp_reg * dtcld, 0.f);\n"
"          xlf = xls - xl_k;\n"
"          xlwork2 = -xl_k * (prevp_reg + psevp_reg);\n"
"          t_k = t_k - xlwork2 / cpm_k * dtcld;\n"
"        }\n"
"        //\n"
"        // Inline expansion for fpvs\n"
"        cvap = cpv;\n"
"        ttp = t0c + 0.01f;\n"
"        dldt = cvap - cliq;\n"
"        xa = -dldt / rv;\n"
"        xb = xa + hvap / (rv * ttp);\n"
"        dldti = cvap - cice;\n"
"        xai = -dldti / rv;\n"
"        xbi = xai + hsub / (rv * ttp);\n"
"        tr = ttp / t_k;\n"
"        qs1_k = psat * expf(logf(tr) * (xa)) * expf(xb * (1.f - tr));\n"
"        qs1_k = ep2 * qs1_k / (p[P3(ti, k, tj)] - qs1_k);\n"
"        qs1_k = MAX(qs1_k, qmin);\n"
"\n"
"        //  pcond: condensational/evaporational rate of cloud water [HL A46]\n"
"        //  [RH83 A6]\n"
"        //     if there exists additional water vapor condensated/if\n"
"        //     evaporation of cloud water is not enough to remove subsaturation\n"
"\n"
"        w1_k = ((MAX(q_k, qmin) - (qs1_k)) /\n"
"                (1.f +\n"
"                 (xl_k) * (xl_k) / (rv * (cpm_k)) * (qs1_k) / ((t_k) * (t_k))));\n"
"        // w3_k = qc_k+w1_k ;   NOT USED\n"
"        pcond_reg = MIN(MAX(w1_k / dtcld, 0.f), MAX(q_k, 0.f) / dtcld);\n"
"        if (qc_k > 0.f && w1_k < 0.f) {\n"
"          pcond_reg = MAX(w1_k, -qc_k) / dtcld;\n"
"        }\n"
"        q_k = q_k - pcond_reg * dtcld;\n"
"        qc_k = MAX(qc_k + pcond_reg * dtcld, 0.f);\n"
"        t_k = t_k + pcond_reg * xl_k / cpm_k * dtcld;\n"
"\n"
"        //     padding for small values\n"
"        if (qc_k <= qmin)\n"
"          qc_k = 0.f;\n"
"        if (qi_k <= qmin)\n"
"          qi_k = 0.f;\n"
"\n"
"        q[P3(ti, k, tj)] = q_k;\n"
"        t[k] = t_k;\n"
"        qr[P3(ti, k, tj)] = qr_k;\n"
"        qc[P3(ti, k, tj)] = qc_k;\n"
"        qs[P3(ti, k, tj)] = qs_k;\n"
"        qi[P3(ti, k, tj)] = qi_k;\n"
"        qs1[k] = qs1_k;\n"
"      }\n"
"    }\n"
"\n"
"    for (k = kps - 1; k <= kpe - 1; k++)\n"
"      th[P3(ti, k, tj)] = t[k] / pii[P3(ti, k, tj)];\n"
"  }\n"
"}\n"
;
